<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Voice Chat</title>
    <style>
      :root{
        --bg: #e7e7ea;
        --shadow-dark: rgba(163, 177, 198, 0.55);
        --shadow-light: rgba(255, 255, 255, 0.95);
        --text: #2b2f36;
        --muted: rgba(43, 47, 54, 0.65);
        --accent: #3b82f6;
        --danger: #ef4444;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: radial-gradient(1200px 800px at 30% 20%, #f2f2f6 0%, var(--bg) 55%, #dfe0e6 100%);
        color: var(--text);
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* ---- Settings panel ---- */
      .settings-bar {
        width: min(620px, 96vw);
        padding: 16px 20px;
        margin-top: 18px;
        border-radius: 18px;
        background: linear-gradient(145deg, #f2f2f6, #d8d9df);
        box-shadow:
          8px 8px 20px var(--shadow-dark),
          -8px -8px 20px var(--shadow-light);
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: flex-end;
      }

      .settings-bar .field {
        display: flex;
        flex-direction: column;
        gap: 3px;
        flex: 1 1 140px;
        min-width: 120px;
      }

      .settings-bar label {
        font-size: 11px;
        font-weight: 650;
        letter-spacing: 0.4px;
        text-transform: uppercase;
        color: var(--muted);
      }

      .settings-bar select,
      .settings-bar input[type="text"] {
        padding: 7px 10px;
        border: 1px solid rgba(0,0,0,0.10);
        border-radius: 10px;
        background: rgba(255,255,255,0.55);
        font-size: 13px;
        font-family: inherit;
        color: var(--text);
        outline: none;
        transition: border-color 150ms;
      }
      .settings-bar select:focus,
      .settings-bar input[type="text"]:focus,
      .settings-bar textarea:focus {
        border-color: var(--accent);
      }

      .settings-bar textarea {
        padding: 7px 10px;
        border: 1px solid rgba(0,0,0,0.10);
        border-radius: 10px;
        background: rgba(255,255,255,0.55);
        font-size: 13px;
        font-family: inherit;
        color: var(--text);
        outline: none;
        transition: border-color 150ms;
        resize: vertical;
        min-height: 42px;
      }

      /* ---- Main stage ---- */
      .stage {
        width: min(520px, 92vw);
        display: grid;
        place-items: center;
        padding: 28px;
        flex: 1;
      }

      .talk {
        --size: min(320px, 72vw);
        width: var(--size);
        height: var(--size);
        border-radius: 999px;
        border: 0;
        background: linear-gradient(145deg, #f2f2f6, #d8d9df);
        box-shadow:
          24px 24px 48px var(--shadow-dark),
          -24px -24px 48px var(--shadow-light);
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        display: grid;
        place-items: center;
        gap: 10px;
        padding: 26px;
        transition: transform 120ms ease, box-shadow 160ms ease, filter 160ms ease;
        position: relative;
        outline: none;
      }

      .talk:active { transform: scale(0.99); }
      .talk:focus-visible {
        box-shadow:
          24px 24px 48px var(--shadow-dark),
          -24px -24px 48px var(--shadow-light),
          0 0 0 4px rgba(59, 130, 246, 0.22);
      }

      .talk .label {
        font-size: clamp(18px, 3.2vw, 22px);
        font-weight: 650;
        letter-spacing: 0.2px;
        text-align: center;
      }
      .talk .sub {
        font-size: clamp(12px, 2.6vw, 14px);
        color: var(--muted);
        text-align: center;
        min-height: 18px;
      }

      .icon {
        width: clamp(44px, 10vw, 58px);
        height: clamp(44px, 10vw, 58px);
        color: rgba(43, 47, 54, 0.78);
        display: grid;
        place-items: center;
        filter: drop-shadow(0 2px 6px rgba(0,0,0,0.07));
      }

      .state-recording {
        background: linear-gradient(145deg, #ececf1, #dadbe2);
        box-shadow:
          inset 18px 18px 40px var(--shadow-dark),
          inset -18px -18px 40px var(--shadow-light);
      }

      .state-recording .icon { color: rgba(239, 68, 68, 0.9); }

      .talk.state-waiting::after {
        content: "";
        position: absolute;
        inset: -18px;
        border-radius: 999px;
        background: radial-gradient(circle, rgba(59,130,246,0.30) 0%, rgba(59,130,246,0.10) 35%, rgba(59,130,246,0) 65%);
        animation: pulse 1.15s ease-in-out infinite;
        pointer-events: none;
        filter: blur(0.2px);
      }

      @keyframes pulse {
        0%   { transform: scale(0.985); opacity: 0.45; }
        50%  { transform: scale(1.02);  opacity: 0.9; }
        100% { transform: scale(0.985); opacity: 0.45; }
      }

      .wave {
        height: 38px;
        display: none;
        align-items: flex-end;
        justify-content: center;
        gap: 8px;
        filter: drop-shadow(0 2px 6px rgba(0,0,0,0.07));
      }
      .wave span {
        width: 8px;
        height: 10px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.85);
        animation: wave 0.95s ease-in-out infinite;
        transform-origin: 50% 100%;
      }
      .wave span:nth-child(2) { animation-delay: 0.12s; opacity: 0.85; }
      .wave span:nth-child(3) { animation-delay: 0.24s; opacity: 0.75; }
      .wave span:nth-child(4) { animation-delay: 0.36s; opacity: 0.85; }
      .wave span:nth-child(5) { animation-delay: 0.48s; opacity: 0.75; }

      @keyframes wave {
        0%   { transform: scaleY(0.35); }
        50%  { transform: scaleY(1.35); }
        100% { transform: scaleY(0.35); }
      }

      .talk.state-playing .wave { display: flex; }
      .talk.state-playing .icon { display: none; }

      /* ---- Text input area ---- */
      .text-input-area {
        width: min(620px, 96vw);
        padding: 0 20px 20px;
        display: flex;
        gap: 10px;
        align-items: stretch;
      }

      .text-input-area input[type="text"] {
        flex: 1;
        padding: 12px 16px;
        border: 1px solid rgba(0,0,0,0.10);
        border-radius: 14px;
        background: rgba(255,255,255,0.55);
        font-size: 15px;
        font-family: inherit;
        color: var(--text);
        outline: none;
        transition: border-color 150ms;
        box-shadow:
          inset 2px 2px 6px var(--shadow-dark),
          inset -2px -2px 6px var(--shadow-light);
      }
      .text-input-area input[type="text"]:focus {
        border-color: var(--accent);
      }

      .text-input-area button {
        padding: 12px 22px;
        border: 0;
        border-radius: 14px;
        background: linear-gradient(145deg, #f2f2f6, #d8d9df);
        box-shadow:
          4px 4px 10px var(--shadow-dark),
          -4px -4px 10px var(--shadow-light);
        font-size: 14px;
        font-weight: 650;
        font-family: inherit;
        color: var(--text);
        cursor: pointer;
        transition: transform 80ms ease, box-shadow 120ms ease;
        white-space: nowrap;
      }
      .text-input-area button:active {
        transform: scale(0.97);
      }
      .text-input-area button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* ---- Response text display ---- */
      .response-text {
        width: min(620px, 96vw);
        padding: 0 20px 18px;
        font-size: 14px;
        color: var(--muted);
        text-align: center;
        min-height: 20px;
        word-break: break-word;
      }

      /* ---- Koboldcpp fields (shown/hidden) ---- */
      .kobold-fields { display: none; }
      .kobold-fields.visible { display: contents; }
    </style>
  </head>
  <body>

    <!-- Settings bar -->
    <div class="settings-bar" id="settingsBar">
      <div class="field">
        <label for="ttsEngine">TTS Engine</label>
        <select id="ttsEngine">
          <option value="kokoro">Kokoro (fast)</option>
          <option value="pocket_tts">Pocket-TTS</option>
          <option value="qwen3_voice_clone">Qwen3 Voice Clone</option>
        </select>
      </div>

      <div class="field" id="voiceField">
        <label for="voiceSelect">Voice</label>
        <select id="voiceSelect"></select>
      </div>

      <div class="field">
        <label for="llmBackend">LLM Backend</label>
        <select id="llmBackend">
          <option value="ollama">Ollama</option>
          <option value="koboldcpp">Koboldcpp</option>
        </select>
      </div>

      <div class="field">
        <label for="llmModel">LLM Model</label>
        <input type="text" id="llmModel" placeholder="e.g. mistral:latest" />
      </div>

      <div class="kobold-fields" id="koboldFields">
        <div class="field">
          <label for="koboldUrl">Koboldcpp URL</label>
          <input type="text" id="koboldUrl" placeholder="http://localhost:5001" />
        </div>
      </div>

      <div class="field" style="flex: 1 1 100%; min-width: 100%;">
        <label for="systemPrompt">System Prompt</label>
        <textarea id="systemPrompt" rows="3" placeholder="e.g. You are a helpful assistant. Keep responses concise."></textarea>
      </div>
    </div>

    <!-- Main talk button -->
    <main class="stage">
      <button id="talkBtn" class="talk state-idle" type="button" aria-label="Tap to talk">
        <div class="icon" aria-hidden="true">
          <svg width="56" height="56" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
            <line x1="12" y1="19" x2="12" y2="23"></line>
            <line x1="8" y1="23" x2="16" y2="23"></line>
          </svg>
        </div>

        <div class="wave" aria-hidden="true">
          <span></span><span></span><span></span><span></span><span></span>
        </div>

        <div class="label" id="label">Tap to talk</div>
        <div class="sub" id="sub">Tap again to send</div>
      </button>
    </main>

    <!-- Response text -->
    <div class="response-text" id="responseText"></div>

    <!-- Text input -->
    <div class="text-input-area">
      <input type="text" id="textInput" placeholder="Type a message instead of speaking..." />
      <button id="sendTextBtn" type="button">Send</button>
    </div>

    <script>
      const API_BASE = "http://localhost:5173";
      const API_URL = `${API_BASE}/chat`;

      const btn = document.getElementById("talkBtn");
      const labelEl = document.getElementById("label");
      const subEl = document.getElementById("sub");
      const responseTextEl = document.getElementById("responseText");

      // Settings elements
      const ttsEngineEl = document.getElementById("ttsEngine");
      const voiceSelectEl = document.getElementById("voiceSelect");
      const voiceFieldEl = document.getElementById("voiceField");
      const llmBackendEl = document.getElementById("llmBackend");
      const llmModelEl = document.getElementById("llmModel");
      const systemPromptEl = document.getElementById("systemPrompt");
      const koboldFieldsEl = document.getElementById("koboldFields");
      const koboldUrlEl = document.getElementById("koboldUrl");

      // Text input elements
      const textInputEl = document.getElementById("textInput");
      const sendTextBtn = document.getElementById("sendTextBtn");

      let currentAudio = null;
      let voices = {};

      // ---- Load config and voices on startup ----

      async function loadConfig() {
        try {
          const [configRes, voicesRes] = await Promise.all([
            fetch(`${API_BASE}/config`),
            fetch(`${API_BASE}/voices`),
          ]);
          const config = await configRes.json();
          voices = await voicesRes.json();

          ttsEngineEl.value = config.tts_engine;
          llmBackendEl.value = config.llm_backend;
          llmModelEl.value = config.llm_model || "";
          koboldUrlEl.value = config.koboldcpp_url || "http://localhost:5001";
          systemPromptEl.value = config.system_prompt || "";

          updateVoiceDropdown(config.tts_engine, config.pocket_tts_voice);
          updateKoboldVisibility();
        } catch (e) {
          console.warn("Could not load config:", e);
        }
      }

      function updateVoiceDropdown(engine, selectedVoice) {
        voiceSelectEl.innerHTML = "";
        const engineVoices = voices[engine] || [];

        if (engineVoices.length === 0) {
          voiceFieldEl.style.display = "none";
          return;
        }

        voiceFieldEl.style.display = "";
        for (const v of engineVoices) {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          voiceSelectEl.appendChild(opt);
        }

        if (selectedVoice && engineVoices.includes(selectedVoice)) {
          voiceSelectEl.value = selectedVoice;
        }
      }

      function updateKoboldVisibility() {
        if (llmBackendEl.value === "koboldcpp") {
          koboldFieldsEl.classList.add("visible");
        } else {
          koboldFieldsEl.classList.remove("visible");
        }
      }

      // ---- Settings change handlers ----

      async function pushConfig(body) {
        try {
          const res = await fetch(`${API_BASE}/config`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          const config = await res.json();
          if (config.errors && config.errors.length) {
            console.warn("Config errors:", config.errors);
          }
          return config;
        } catch (e) {
          console.error("Failed to push config:", e);
          return null;
        }
      }

      ttsEngineEl.addEventListener("change", async () => {
        const engine = ttsEngineEl.value;
        const config = await pushConfig({ tts_engine: engine });
        if (config) {
          updateVoiceDropdown(engine, config.pocket_tts_voice);
        }
      });

      voiceSelectEl.addEventListener("change", async () => {
        const engine = ttsEngineEl.value;
        if (engine === "pocket_tts") {
          await pushConfig({ pocket_tts_voice: voiceSelectEl.value });
        }
      });

      llmBackendEl.addEventListener("change", async () => {
        updateKoboldVisibility();
        await pushConfig({ llm_backend: llmBackendEl.value });
      });

      // Push LLM model on Enter or blur
      llmModelEl.addEventListener("change", async () => {
        const val = llmModelEl.value.trim();
        if (val) await pushConfig({ llm_model: val });
      });

      koboldUrlEl.addEventListener("change", async () => {
        const val = koboldUrlEl.value.trim();
        if (val) await pushConfig({ koboldcpp_url: val });
      });

      systemPromptEl.addEventListener("change", async () => {
        const val = systemPromptEl.value.trim();
        await pushConfig({ system_prompt: val });
      });

      // ---- State management ----

      function setState(state, { label, sub, ariaLabel } = {}) {
        btn.classList.remove("state-idle", "state-recording", "state-waiting", "state-playing");
        btn.classList.add(`state-${state}`);
        if (label != null) labelEl.textContent = label;
        if (sub != null) subEl.textContent = sub;
        if (ariaLabel != null) btn.setAttribute("aria-label", ariaLabel);
      }

      // ---- Audio helpers ----

      function flattenFloat32(chunks) {
        const total = chunks.reduce((sum, c) => sum + c.length, 0);
        const out = new Float32Array(total);
        let offset = 0;
        for (const c of chunks) {
          out.set(c, offset);
          offset += c.length;
        }
        return out;
      }

      function encodeWavPcm16(monoFloat32, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const blockAlign = (numChannels * bitsPerSample) / 8;
        const byteRate = sampleRate * blockAlign;
        const dataSize = monoFloat32.length * 2;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        let p = 0;
        const writeU32 = (v) => { view.setUint32(p, v, true); p += 4; };
        const writeU16 = (v) => { view.setUint16(p, v, true); p += 2; };
        const writeStr = (s) => { for (let i = 0; i < s.length; i++) view.setUint8(p++, s.charCodeAt(i)); };

        writeStr("RIFF");
        writeU32(36 + dataSize);
        writeStr("WAVE");
        writeStr("fmt ");
        writeU32(16);
        writeU16(1);
        writeU16(numChannels);
        writeU32(sampleRate);
        writeU32(byteRate);
        writeU16(blockAlign);
        writeU16(bitsPerSample);
        writeStr("data");
        writeU32(dataSize);

        for (let i = 0; i < monoFloat32.length; i++) {
          const s = Math.max(-1, Math.min(1, monoFloat32[i]));
          view.setInt16(p, s < 0 ? s * 0x8000 : s * 0x7fff, true);
          p += 2;
        }

        return buffer;
      }

      // ---- Play audio response ----

      function playAudioBlob(blob, chatResponseText) {
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        currentAudio = audio;

        if (chatResponseText) {
          responseTextEl.textContent = chatResponseText;
        }

        audio.onended = () => {
          URL.revokeObjectURL(url);
          if (currentAudio === audio) currentAudio = null;
          setState("idle", { label: "Tap to talk", sub: "Tap again to send", ariaLabel: "Tap to talk" });
        };
        audio.onerror = () => {
          URL.revokeObjectURL(url);
          setState("idle", { label: "Tap to talk", sub: "Audio playback failed.", ariaLabel: "Tap to talk" });
        };

        audio.play().then(() => {
          setState("playing", { label: "Playing...", sub: "Tap to interrupt", ariaLabel: "Playing audio" });
        }).catch(() => {
          setState("idle", { label: "Tap to talk", sub: "Playback blocked by the browser.", ariaLabel: "Tap to talk" });
        });
      }

      // ---- Voice chat flow ----

      async function fetchAndPlayTts(wavBlob) {
        setState("waiting", { label: "Sending...", sub: "Waiting for response", ariaLabel: "Waiting for response" });

        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        const res = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "audio/wav" },
          body: wavBlob,
        });

        if (!res.ok) {
          setState("idle", { label: "Tap to talk", sub: `Error: ${res.status}`, ariaLabel: "Tap to talk" });
          return;
        }

        const blob = await res.blob();
        playAudioBlob(blob);
      }

      // ---- Text chat flow ----

      async function sendTextMessage(text) {
        if (!text.trim()) return;

        setState("waiting", { label: "Processing...", sub: "Generating response", ariaLabel: "Processing text" });
        textInputEl.disabled = true;
        sendTextBtn.disabled = true;

        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
        }

        try {
          const res = await fetch(`${API_BASE}/chat/text`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: text.trim() }),
          });

          if (!res.ok) {
            setState("idle", { label: "Tap to talk", sub: `Error: ${res.status}`, ariaLabel: "Tap to talk" });
            return;
          }

          const chatResponse = res.headers.get("X-Chat-Response") || "";
          const blob = await res.blob();
          textInputEl.value = "";
          playAudioBlob(blob, chatResponse);
        } catch (err) {
          setState("idle", { label: "Tap to talk", sub: "Request failed", ariaLabel: "Tap to talk" });
        } finally {
          textInputEl.disabled = false;
          sendTextBtn.disabled = false;
          textInputEl.focus();
        }
      }

      sendTextBtn.addEventListener("click", () => {
        sendTextMessage(textInputEl.value);
      });

      textInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendTextMessage(textInputEl.value);
        }
      });

      // ---- Recording ----

      let recording = null;

      async function startRecording() {
        if (!navigator.mediaDevices?.getUserMedia) {
          setState("idle", { label: "Unsupported", sub: "Microphone not available", ariaLabel: "Microphone unsupported" });
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true, autoGainControl: true },
          });

          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const processor = audioContext.createScriptProcessor(4096, 1, 1);
          const zeroGain = audioContext.createGain();
          zeroGain.gain.value = 0;

          const chunks = [];
          processor.onaudioprocess = (e) => {
            const data = e.inputBuffer.getChannelData(0);
            chunks.push(new Float32Array(data));
          };

          source.connect(processor);
          processor.connect(zeroGain);
          zeroGain.connect(audioContext.destination);

          recording = { stream, audioContext, source, processor, zeroGain, chunks };
          setState("recording", { label: "Listening...", sub: "Tap to stop & send", ariaLabel: "Recording audio" });
        } catch (err) {
          setState("idle", { label: "Tap to talk", sub: "Mic permission denied", ariaLabel: "Tap to talk" });
        }
      }

      async function stopRecording() {
        const r = recording;
        recording = null;
        if (!r) return null;

        const sampleRate = r.audioContext.sampleRate;
        try { r.processor.disconnect(); } catch {}
        try { r.zeroGain.disconnect(); } catch {}
        try { r.source.disconnect(); } catch {}
        try { r.stream.getTracks().forEach((t) => t.stop()); } catch {}
        try { await r.audioContext.close(); } catch {}

        const mono = flattenFloat32(r.chunks);
        const wavBuffer = encodeWavPcm16(mono, sampleRate);
        return new Blob([wavBuffer], { type: "audio/wav" });
      }

      btn.addEventListener("click", async () => {
        if (btn.classList.contains("state-waiting")) return;

        if (btn.classList.contains("state-playing")) {
          if (currentAudio) currentAudio.pause();
          currentAudio = null;
          setState("idle", { label: "Tap to talk", sub: "Tap again to send", ariaLabel: "Tap to talk" });
          return;
        }

        if (!recording) {
          await startRecording();
          return;
        }

        setState("waiting", { label: "Processing...", sub: "Sending audio", ariaLabel: "Sending audio" });
        const wavBlob = await stopRecording();
        if (!wavBlob) {
          setState("idle", { label: "Tap to talk", sub: "Tap again to send", ariaLabel: "Tap to talk" });
          return;
        }

        try {
          await fetchAndPlayTts(wavBlob);
        } catch (err) {
          setState("idle", { label: "Tap to talk", sub: "Request failed", ariaLabel: "Tap to talk" });
        }
      });

      // ---- Init ----
      loadConfig();
    </script>
  </body>
</html>
